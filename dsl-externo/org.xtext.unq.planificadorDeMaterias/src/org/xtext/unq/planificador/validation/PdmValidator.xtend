/*
 * generated by Xtext
 */
package org.xtext.unq.planificador.validation

import java.util.List
import org.eclipse.xtext.validation.Check
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Asignacion
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Aula
import org.xtext.unq.planificador.planificadorDeMateriasDsl.AulaHorario
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Dia
import org.xtext.unq.planificador.planificadorDeMateriasDsl.DiaHorario
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Horario
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Materia
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Model
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Planificacion
import org.xtext.unq.planificador.planificadorDeMateriasDsl.PlanificadorDeMateriasDslPackage
import org.xtext.unq.planificador.planificadorDeMateriasDsl.Profesor

//import org.eclipse.xtext.validation.Check
/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class PdmValidator extends AbstractPdmValidator {

	@Check
	def esHorarioValido(Horario horario) {
		if (horario.desde < 0 || horario.desde > 24) {
			error("Horario desde tiene formato invalido", horario,
				PlanificadorDeMateriasDslPackage.Literals.HORARIO__DESDE)
		}

		if (horario.hasta < 0 || horario.hasta > 24) {
			error("Horario hasta tiene formato invalido", horario,
				PlanificadorDeMateriasDslPackage.Literals.HORARIO__HASTA)
		}
	}

	// Valida si las materias creadas estan asignadas a la planificacion
	@Check
	def validateMateriasAsignadas(Planificacion p) {
		var model = p.eContainer as Model
		for (Materia m : model.elementosPrimarios.filter(Materia)) {
			p.estaAsignado(m)

		}
	}

	def estaAsignado(Planificacion p, Materia m) {
		if (!p.asignaciones.exists[a|a.materia.name.equals(m.name)]) {
			error("Falta asignar una materia", m, PlanificadorDeMateriasDslPackage.Literals.MATERIA__NAME)
		}
	}
	//*************************************************************************************************

	//Valida que las aulas no esten repetidas.
	@Check
	def validateAulasRepetidas(Model m){
		val aulas = m.elementosSecundarios.filter(Aula)
		aulas.forEach[aula |
			estaRepetidaElAula(aula, aulas)
		]
	}

	def estaRepetidaElAula(Aula aula, Iterable<Aula> aulas){
		var count = 0
		for(Aula a : aulas){
			if(aula.name.equals(a.name)){
				count = count + 1
			}
		}
		if (count >= 2) {
			error("Aula repetida", aula, PlanificadorDeMateriasDslPackage.Literals.AULA__CAPACIDAD)
		}
	}
	//*************************************************************************************************
	
	//Valida que las materias creadas no esten repetidas
	@Check
	def validateMateriasRepetidas(Model m) {
		val materias = m.elementosPrimarios.filter(Materia)
		materias.forEach[materia|estaRepetidaLaMateria(materia, materias)]
	}

	def estaRepetidaLaMateria(Materia materia, Iterable<Materia> m) {
		var count = 0
		for (Materia mat : m) {
			if (mat.name.equals(materia.name)) {
				count = count + 1
			}
		}
		if (count >= 2) {
			error("Materia repetida", materia, PlanificadorDeMateriasDslPackage.Literals.MATERIA__NAME)
		}
	}
	//*************************************************************************************************
	
	//Valida, segun la dedicacion del profesor, que tenga asignada la cantidad correcta de materias.
	@Check
	def validateDedicacion(Profesor p) {
		p.materiasQueDicta(p.eContainer as Model)
	}

	def materiasQueDicta(Profesor p, Model model) {
		var planificaciones = model.planificacion
		var count = 0
		for (Planificacion planificacion : planificaciones) {
			for (Asignacion a : planificacion.asignaciones) {
				if (a.profesores.exists[profe|profe.name.equals(p.name)]) {
					count = count + 1
				}
			}
			p.validarDedicacion(count, planificacion)
			count = 0
		}
	}

	def validarDedicacion(Profesor p, int materiasQueDicta, Planificacion pl) {
		if ((p.dedicacion.eClass.name.equals("EXCLUSIVA")) && (materiasQueDicta < 2 || materiasQueDicta > 5)) {
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 2 hasta 5 materias''', p,
				PlanificadorDeMateriasDslPackage.Literals.PROFESOR__NAME)
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 2 hasta 5 materias''', pl,
				PlanificadorDeMateriasDslPackage.Literals.PLANIFICACION__ASIGNACIONES)
		}
		if ((p.dedicacion.eClass.name.equals("SEMI")) && (materiasQueDicta != 2)) {
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 2 materias''', p,
				PlanificadorDeMateriasDslPackage.Literals.PROFESOR__NAME)
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 2 materias''', pl,
				PlanificadorDeMateriasDslPackage.Literals.PLANIFICACION__ASIGNACIONES)
		}
		if (p.dedicacion.eClass.name.equals("SIMPLE") && (materiasQueDicta != 1)) {
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 1 materia''', p,
				PlanificadorDeMateriasDslPackage.Literals.PROFESOR__NAME)
			error('''Tiene «materiasQueDicta» materia asignada y necesita de 1 materia''', pl,
				PlanificadorDeMateriasDslPackage.Literals.PLANIFICACION__ASIGNACIONES)
		}
	}
	//*************************************************************************************************
	
	//Valida que las aulas asignadas no se superpongan con el horario en que se dictan las materias.
	@Check
	def validateSuperposicionDeMateriasEnAulas(Model m) {
		val model = m
		var planificaciones = model.planificacion
		planificaciones.forEach[planificacion | 
			planificacion.asignaciones.forEach[asignacion | 
				asignacion.aulaHorarios.forEach[aulaHorario | 
					chequearHorarioSuperpuesto(planificacion, aulaHorario)
				]
			]
		]
	}

	def chequearHorarioSuperpuesto(Planificacion planificacion, AulaHorario aulaHorario) {

		for (Asignacion asignacion : planificacion.asignaciones) {

			val desde = aulaHorario.horario.desde
			val hasta = aulaHorario.horario.hasta
			var existe = asignacion.aulaHorarios.exists [ aHorario |
				( (aHorario.horario.desde > desde && aHorario.horario.desde < hasta) ||
				  (aHorario.horario.hasta > desde && aHorario.horario.hasta < hasta) ||
				  (aHorario.horario.desde == desde && aHorario.horario.hasta == hasta)) &&
				  (aulaHorario.aula.name.equals(aHorario.aula.name)) &&
				  (aulaHorario.dia.eClass.name.equals(aHorario.dia.eClass.name)) &&
				  (!(aulaHorario.hashCode.equals(aHorario.hashCode)))
			]

			if (existe) {
				error('''El horario en el aula ya esta en uso''', asignacion,
					PlanificadorDeMateriasDslPackage.Literals.ASIGNACION__AULA_HORARIOS)
			}

		}

	}
	//*************************************************************************************************

	//Valida que en la asignacion de materias no tenga dias repetidos.
	@Check
	def validateDiasRepetidos(Planificacion p){
		p.asignaciones.forEach[asignacion | 
			asignacion.aulaHorarios.forEach[aulaHorario |
				aulaHorario.dia.estaRepetidoElDia(asignacion.aulaHorarios)	
			]
		]
	}	
	
	def estaRepetidoElDia(Dia dia, Iterable<AulaHorario> aulaHorarios) {
		var count = 0
		for (AulaHorario ah : aulaHorarios) {
			if (ah.dia.eClass.name.equals(dia.eClass.name)) {
				count = count + 1
			}
			if (count >= 2) {
				error("Dia repetido", ah, PlanificadorDeMateriasDslPackage.Literals.AULA_HORARIO__DIA)
			}
		}
	}
	//*************************************************************************************************
	
	//Valida que los dias y horas que se dicta la materia en la semana sean asignados correctamente.
	@Check
	def validateCargaHorariaMaterias(Planificacion p){
		p.asignaciones.forEach[asignacion |
			asignacion.chequearCantidadDiasSemanales
			asignacion.chequearCantidadHorasSemanales
		]
	}
	
	def chequearCantidadHorasSemanales(Asignacion asignacion){
		var horasSemanales = asignacion.horasSemanales() 
		var String mensajeDeError = ""
		var horasAsignadas = asignacion.materia.cargaHoraria.cantHoras
		if(horasSemanales != horasAsignadas){
			if(horasSemanales == 1){
				mensajeDeError = '''La materia se dicta «horasSemanales» hora a la semana, y tiene asignadas «horasAsignadas» horas'''
			}else{
				if(horasAsignadas == 1){
					mensajeDeError = '''La materia se dicta «horasSemanales» horas a la semana, y tiene asignada «horasAsignadas» hora'''	
				}else{
						mensajeDeError = '''La materia se dicta «horasSemanales» horas a la semana, y tiene asignadas «horasAsignadas» horas'''
				}
			}
			error(mensajeDeError, asignacion, PlanificadorDeMateriasDslPackage.Literals.ASIGNACION__MATERIA)
		}
	}
	
	def chequearCantidadDiasSemanales(Asignacion asignacion){
		var String mensajeDeError = ""
		var diasSemanales = asignacion.materia.cargaHoraria.diasSemanales
		var diasAsignados = asignacion.aulaHorarios.size
		if( diasSemanales != diasAsignados){
			if(diasSemanales == 1){
				mensajeDeError = '''La materia se dicta «diasSemanales» dia a la semana, y tiene asignados «diasAsignados» dias'''
			}else{
				if(diasAsignados == 1){
					mensajeDeError = '''La materia se dicta «diasSemanales» dias a la semana, y tiene asignado «diasAsignados» dia'''	
				}else{
					mensajeDeError = '''La materia se dicta «diasSemanales» dias a la semana, y tiene asignados «diasAsignados» dias'''
				}
			}
			error(mensajeDeError, asignacion, PlanificadorDeMateriasDslPackage.Literals.ASIGNACION__MATERIA)
		}
	}
	
	def horasSemanales(Asignacion asignacion){
		var horas = 0
		for(AulaHorario aulaHorario : asignacion.aulaHorarios){
			horas = horas + (aulaHorario.horario.hasta - aulaHorario.horario.desde)
		}
		horas
	}
	//*************************************************************************************************
	
	//Valida que el aula cuente con la capacidad suficiente de inscriptos a una materia determinada.
	@Check
	def validateCantidadInscriptos(Planificacion p){
		p.asignaciones.forEach[asignacion |
			asignacion.aulaHorarios.forEach[aulaHorario |
				if(aulaHorario.aula.capacidad < asignacion.inscriptos){
					error('''El aula no tiene la capacidad («aulaHorario.aula.capacidad») necesaria para «asignacion.inscriptos» inscriptos''', asignacion, PlanificadorDeMateriasDslPackage.Literals.ASIGNACION__INSCRIPTOS)
				}
			]
		]
	}
	//*************************************************************************************************
	
	//Valida que el aula cuente con los recursos necesarios que la materia asignada necesite.
	@Check
	def validateRecursos(Planificacion planificacion){
		planificacion.asignaciones.forEach[asignacion |
			tieneLosRecursosNecesarios(asignacion.materia, asignacion.aulaHorarios)
		]
	}

	def tieneLosRecursosNecesarios(Materia materia, List<AulaHorario> aulaHorarios){
		materia.recursos.forEach[recurso | 
			aulaHorarios.forEach[aHorario |
				if(!(aHorario.aula.recursos.exists[rec | rec.name.equals(recurso.name)])){
					error("El aula no tiene los recursos necesarios para la materia", aHorario, PlanificadorDeMateriasDslPackage.Literals.AULA_HORARIO__AULA)
				}
			]
		]
	}
	//*************************************************************************************************

	//Valida que los horarios de los cursos asignados a cada profesor cumplan con la disponibilidad del profesor
	@Check
	def validateProfesorConCurso(Model m){
		var model=m
		var planificaciones=model.planificacion
		for(Planificacion planificaion:planificaciones){
			for(Asignacion asignacion:planificaion.asignaciones){
				for(Profesor profesor:asignacion.profesores){
					try {
						chequearDisponibilidadAsignacion(profesor,asignacion)
					}catch(Exception e){
						//nalga
					}
				}
			}
		}
	}
	
	def chequearDisponibilidadAsignacion(Profesor profesor, Asignacion asignacion) {
		if(asignacion.profesores.exists[p | p.name.equals(profesor.name)]){
			

			for(AulaHorario aulaHorario:asignacion.aulaHorarios){
				if(profesor.disponibilidad.diasNoPuede.exists[d | d.eClass.name.equals(aulaHorario.dia.eClass.name)]){
					error("El profesor especifico que no puede asistir ese dia", aulaHorario, PlanificadorDeMateriasDslPackage.Literals.AULA_HORARIO__DIA)
				}
				if(!profesor.disponibilidad.diasHorario.exists[dh | dh.diaPuede.class.name.equals(aulaHorario.dia.class.name)]){
					warning("Puede ser que el profesor no pueda asistir,debido a que el dia no fue especificado en su disponibilidad", aulaHorario, PlanificadorDeMateriasDslPackage.Literals.AULA_HORARIO__DIA)
				} else{
					if(!profesor.disponibilidad.diasHorario.exists[dh | coincidenHorariosDisponibles(dh,aulaHorario)]){
						error("El profesor no esta disponible en este horario", aulaHorario, PlanificadorDeMateriasDslPackage.Literals.AULA_HORARIO__DIA)
					}
				}
			}
		}
	}
	
	def coincidenHorariosDisponibles(DiaHorario diaHorario, AulaHorario ahorario) {
		ahorario.horario.desde >= diaHorario.horario.desde && 
		ahorario.horario.hasta <= diaHorario.horario.hasta
	}

	//*************************************************************************************************
}




